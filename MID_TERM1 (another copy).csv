1,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make the common case fast. Simplicity and regularity is better. Reduced instruction set and registers. Make compromise for good design.,3
2,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The memory consumed must be smallest with smallest instruction set. ,3
3,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple is better. Common case should be faster.,3
4,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler is faster. Smaller is faster. Maintain its agreements.,3
5,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,In this instructions are minimized and achieve more accuracy. ,3
6,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler is faster. Less registers and memory addresses usage will be less complex.,3
7,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple is faster. Reduce instruction set computing. ,3
8,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS RISC design principles work on big endian.,3
9,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Smaller is better. Limited number of registers and instructions. High performance. ,3
10,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Smaller is faster. Easy common case execution as it lets instructions have intermediates.,3
11,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS follows Big Endian format. Each instruction in MIPS is 32 bits. ,3
12,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It is simple instruction set. It has fixed instruction format. Follows big endian byte ordering. ,3
13,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS are based on million instruction pipelined stages and rise is on simpler instructions. MIPS instructions are more simplified. ,3
14,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple and elegant design. Reduced and simple instructions. Compromises are made to achieve perfection. Everything handled with 32 bit registers. ,3
15,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make it simple. Make the common code faster. ,3
16,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Smaller instructions. Faster but difficult to code. Smaller instruction means higher performance. ,3
17,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Keep instruction as simple as possible. Every register is 32 bits. Keep minimum number of instructions. ,3
18,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple hardware can be implemented faster. Good compromise is needed. Optimize the common case. Minimize number of instructions.,3
19,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Alignment of code. Ordering of code. Microprocessor interlocking. ,3
20,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It is always written in read and write form. Memory is always addressable. ,3
21,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It should be simple. It should have less build instructions. Same instruction formats should be followed. ,3
22,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity over complexity. Easy to use. ,3
23,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Short and easily executable. Faster instruction. ,3
24,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple instruction. Aligned memory addressing. Combining simple functions to perform complex tasks. ,3
25,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler is better. ,3
26,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS design principle is less instructions or less number of register used more efficient will be the code where a RISC state we can have as many instructions as possible. ,3
27,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler is better. Simplifying has its compromises. ,3
28,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Less instructions. Simple. ,3
29,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple and small instructions. Faster to execute. ,3
30,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple instructions. Simple to execute. Reduced set of instructions. ,3
31,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make simple and less instructions. Make the common case fast. ,3
32,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Smaller program is better. Lesser instructions. Simpler instructions. Make the common case faster. ,3
33,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity and fewer instructions each instruction of 32 bit. Most used comparison cases are easy to use. No unnecessary instructions. ,3
34,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Smaller is faster. Fewer instruction commands. Simple code. Less instructions. ,3
35,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity favors regularity. Smaller is better. Good design requires good compromise. Make the common case good. ,3
36,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make the common case fast. Simplicity and regularity is better. Reduced instruction set and registers. Make compromise for good design. ,3
37,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Common case faster. Smaller is faster. Simplicity In design. ,3
38,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity defines regularity. Make the common case fast. Smaller instruction set. Can compromise on design. ,3
39,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler and faster. Smaller instructions. Common case is faster. ,3
40,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity favors regularity. Smaller is faster. Make the common case fast. Good design demands good compromise. ,3
41,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Only three type of instructions. Few and fixed number of instructions. Make the common case fast. Operands are stored in registers and immediate load into instructions. ,3
42,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity is regularity. Make common case faster. Smaller is better. Complex operations require compromise. ,3
43,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler is better. Smaller is faster. Make common case faster. Make compromise for good design. ,3
44,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It makes the common case fast. The simplicity maintains regularity. Smaller is faster. Consistent Design. ,3
45,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It maintains stability through fewer formats and fixed instructions sizes. Simpler is faster because of small instructions and faster execution. It makes the common case fast. ,3
46,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The smaller is faster. The better design demand compromise. The simplicity favour regularity. ,3
47,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"Simpler is better because instructions are simple. Smaller is faster since size of each instruction in MIPS have less bits, Registers all can be located using 5 bits. It makes the common case faster by speeding up the most commonly used instruction to aim more speed. ",3
48,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"It makes the common case faster. The simpler it is the faster it is. It reduces the instruction, because less registers used and the faster the program is. ",3
49,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The simplicity favours regularity. The good design demands good compromise. It makes the common case faster. ,3
50,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The simplicity forms regularity. The good design demands good compromise. The smaller it is the faster it is. ,3
51,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Same size instructions; easier to decode. Same general format of instructions. Lesser instructions lessor instruction set for codes. Breakdwon of big instructions into memore little instructions. Limited flexibility to avoid complexities. General addressing techniques to make most of resources. ,3
52,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"MIPS: Multiple Instructions per second, no of instructions more. RISC: Reduced Instruction per second, no of instruction less. ",3
53,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple instruction set. Use register to execution. Small and fast execution. ,3
54,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Try to fit an instruction in the smallest possible format. Rformat is given priority. Instructions should be simple. No wastage of memory space. ,3
55,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Operand sizes. Memory alignment. Big Endian Byte Ordering. Register Addressing. ,3
56,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple is faster. ,3
57,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Minimum number of instructions. Less is faster. ,3
58,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity maintains regularity. Few statements and formats. Arithmetic and load/store operations computations is fast. ,3
59,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instructions. Easier to code. Small instructions. ,3
60,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Least number of instructions. Least number of registers used. ,3
61,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instructions. Less is more efficient and good. Simple instruction set. 32 bits instructions. ,3
62,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,In RISC it is simple format. ,3
63,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"Fewer instructions formats (R,I,J). Smaller are better. Operands are registers. Registers are 32 bit wide. Instructions are byte addressible. Operations on registers are fast because they are located inside. ",3
64,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"Reduced instruction set architecture that uses Big Endian Byte Ordering for e.g add is not equal to rd, rs, rt. ",3
65,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Less instruction. Smaller code. Faster code. ,3
66,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced Instruction set. Ease of usage. Similar instruction. Faster for user as instructions are less. ,3
67,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"Simplicity, it means we have fewer formats of instructions (R,I,J). And size of each instruction is fixed. Common operations are faster because immediates are placed inside the instruction to increase speed. Operands are also placed in register. The lesser is faster since few addressing modes and few registers (32). Less instructions to perform all types of operations. ",3
68,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The simpler is faster. Simplicity is the regularity. Greater case is common in effect. ,3
69,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity favours regularity. It makes the common case fast. ,3
70,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,32 bits 32 register. Simpler because of the less instructions. Registers instead of variables. ,3
71,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The simplicity is regularity. The smaller is the faster. It makes the common case faster. ,3
72,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity - less formats. The common case are fastest. Arithmetics operands in registers. Immediate encode in instructions. ,3
73,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The shorter is faster. The simpler is faster. Less number of instructions. ,3
74,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"Multiplexed interlocked pipeline system RISC is a simple and faster architecture design with fewer instruction formats i.e. I, R and J, where I is the immediate type, J is jummp type format and R is register type format. It is easier. ",3
75,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It makes the common case fast. It uses less registers ( smaller is faster). Use less number of instruction types. Favour R type instructions. ,3
76,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple because of less instruction set. Smaller is better because of reduced code. ,3
77,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity is a better choice it keeps the harware simple. Reduce the instructions as much as possbile. ,3
78,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple instruction. Less instructions. Less registers used. ,3
79,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple. ,3
80,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The smaller is faster. Simplicity maintains regularity. It makes the common case faster. ,3
81,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"It is a simple architecture have 3 formats only for simplicity I type, T type, R type. It has 32 registers. It uses simple instructions. ",3
82,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The simpler is faster. The shorter is better. Consistent length of instructions. ,3
83,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity (simple is better) (simple instructions). The shorter is better. Consistent length of instructions. ,3
84,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity. ,3
85,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,"four design principles,It should be simple. Simpilicity demands.",3
86,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Only registers are used. direct memory used. ,3
87,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,for good performance we have to compromise. ,3
88,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The instructions are smaller. Efficient for most used cases. Size of all instructions is same. ,3
89,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simple means regularity. Smaller is better. Common cases are fast. ,3
90,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,All instructions should be of same type. Reduced set of instructions. ,3
91,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Good design demands good compromise. Shorter and simpler instructions are better. Make common case fast. ,3
92,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS is simpler and better and faster. MIPS has reuduced instruction set. MIPS uses only 32 registers. MIPS executes are instructions per line. MIPS performs one operation per instruction. MIPS is interlocked structure. MIPS desig is simpler and faster. ,3
93,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instruction set. More complex instructions. Less number of instuctions. Multiple instructions can be used at once. It is complex to understand. ,3
94,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make common cases Fast. Simplicity favours regularity. ,3
95,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make common cases Faster. Smaller is better.,3
96,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instruction set architecture. Three Address formats.,3
97,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,3
98,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Make instructions simpler. Make instructions similiar. Compromise complexity with efficiency. Make execution shorter.,3
99,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Small instruction set architecture more speed. Don't use multiple instruction formats simple is better. Fast register more performance.,3
100,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It should be simpler. It should be smaller.,3
101,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,In MIPS architecture both the instructions and address are stored in the same memory.,3
102,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It should be simpler. It should be smaller. ,3
103,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Code should be simple. Length of code is small. Less use of variable because limitted number of registers. Proper use of register.,3
104,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Change the repeating section. keep the design simpler.,3
105,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Design is simpler. Is has regularity. Good Compromise for performance. ,3
106,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It has Simple design. Smaller. Memory. ,3
107,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity gives regularity. Small is better. Good design demands good compromise.,3
108,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,concise is better. use of less concise instructions. Better decoder at hardware level. Fast processing due to registers. Increase in one ring will decrease in other ring.,3
109,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Simplicity favours regularity. Good design demands good compromise. Smaller is better. ,3
110,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Less number of instructions. Compromise if instruction has more clock cycles. Smaller is faster. Same instruction format. ,3
111,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Instructions should be of same format. First comes operation then destination and then source. ,3
112,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,MIPS is faster. Less instructions then RISC,3
113,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Good design demands compromise. Good design should have fewer instructions. Good principal demands good design. ,3
114,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instruction set. ,3
115,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,The design is simple. Good design demands compromise. Make common cases faster. ,3
116,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,Reduced instruction set. ,3
117,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,It uses little endian order. ,3
118,Simpler design increases performance. Smaller is faster. Good design demands good compromise. Make the common cases faster.,simpler is better. simpler is faster.,3
